"""Изучаем связанные списки - ex01.py"""


class ListNode:
    """Узел связанного списка"""
    def __init__(self, val=None, next_node=None):
        """
        Параметры инициализирующего метода опциональны. По умолчанию и данные,
        val, и ссылка, next_node получают значения None.

        :param val:
        :param next_node:
        """
        self.val = val
        self.next = next_node

    def __str__(self):
        """
        Метод отображения объектов класса. Строковым представлением узла будет
        строковое представление данных этого узла. Поскольку функции str можно
        передать любое значение, в узле можно будет хранить любое значение.
        :return:
        """
        return str(self.val)


# Функция print_list принимает один узел в качестве аргумента. Начиная с первого
# узла списка, она выводит на печать каждый узел, пока не достигнет его конца.
def print_list(node: ListNode):
    """
    Функция вывода на печать связанного списка.\n
    Хотя у функции есть ссылка на первый узел списка, внутри неё нет переменных,
    ссылающихся на другие узлы. Функция получает ссылку на следующий узел,
    используя значение атрибута next каждого узла.

    :param node: ссылка на первый узел списка.
    :return:
    """
    while node:
        print(node)
        node = node.next
    print()


# Многие операции над списком естественно реализовать с помощью рекурсивных
# методов. Вот рекурсивный алгоритм для вывода на печать списка в обратном
# порядке:
# 1. Разделить список на две части: первый узел (голова) и все остальные (хвост)
# 2. Распечатать хвост в обратном порядке.
# 3. Распечатать голову.
# Разумеется, шаг 2, рекурсивный вызов предполагает, что у нас имеется способ
# распечатать список в обратном порядке. Но если мы примем, что рекурсивный
# вызов работает - нужно в это поверить - то мы можем убедиться в том, что
# алгоритм работает.
# Всё, что нам нужно, это простейший случай списка (базовый случай) и
# доказательство того, что, какой бы список мы ни взяли, наш алгоритм в конце
# концов приведёт нас к этому базовому случаю. Имея рекурсивное определение
# списка, приведённое выше, в качестве базового случая возьмём пустой список,
# представленный значением None:
def print_backward(list_head: ListNode):
    """Вывод на печать связанного списка в обратном порядке"""
    if list_head is None:
        return
    _ = list_head  # head
    tail = list_head.next
    print_backward(tail)
    print(list_head)


def main():
    """
    Function main

    :return:
    """
    # для тестирования создадим объект ListNode и выведем его на печать.
    node = ListNode("test")
    print(node)  # test

    # Для продолжения тестирования создадим три узла:
    node1 = ListNode(1)
    node2 = ListNode(2)
    node3 = ListNode(3)
    # Но у нас нет пока списка, так как ни один узел не связан с другим.
    # ------------------------------------------------------------------------
    # Для связи узлов нужно заставить первый узел ссылаться на второй, а второй
    # - на третий:
    node1.next = node2
    node2.next = node3
    # Ссылка в третьем узле имеет значение None, что означает конец списка.
    # Теперь знаем, как создавать узлы и связывать их в списки. Но, возможно,
    # пока не понимаем, зачем это нужно.
    # ------------------------------------------------------------------------
    # Списки полезны, поскольку дают возможность собрать многочисленные объекты
    # в единую сущность, иногда называемую коллекцией. В примере выше, первый
    # узел списка может служить ссылкой на весь список. Чтобы передать связный
    # список в качестве аргумента, достаточно передать ссылку на первый узел.
    # Например, функция print_list принимает один узел в качестве аргумента.
    print_list(node1)
    print_backward(node1)


if __name__ == '__main__':
    main()
