"""Изучаем связанные списки - ex02.py"""


class ListNode:
    """Узел связанного списка"""
    def __init__(self, val=None, next_node=None):
        """
        Параметры инициализирующего метода опциональны. По умолчанию и данные,
        val, и ссылка, next_node получают значения None.

        :param val:
        :param next_node:
        """
        self.val = val
        self.next = next_node

    def __str__(self):
        """
        Метод отображения объектов класса. Строковым представлением узла будет
        строковое представление данных этого узла. Поскольку функции str можно
        передать любое значение, в узле можно будет хранить любое значение.
        :return:
        """
        return str(self.val)


# Функция print_list принимает один узел в качестве аргумента. Начиная с первого
# узла списка, она выводит на печать каждый узел, пока не достигнет его конца.
def print_list(node: ListNode):
    """
    Функция вывода на печать связанного списка.\n
    Хотя у функции есть ссылка на первый узел списка, внутри неё нет переменных,
    ссылающихся на другие узлы. Функция получает ссылку на следующий узел,
    используя значение атрибута next каждого узла.

    :param node: ссылка на первый узел списка.
    :return:
    """
    while node:
        print(node)
        node = node.next
    print()


# Многие операции над списком естественно реализовать с помощью рекурсивных
# методов. Вот рекурсивный алгоритм для вывода на печать списка в обратном
# порядке:
# 1. Разделить список на две части: первый узел (голова) и все остальные (хвост)
# 2. Распечатать хвост в обратном порядке.
# 3. Распечатать голову.
# Разумеется, шаг 2, рекурсивный вызов предполагает, что у нас имеется способ
# распечатать список в обратном порядке. Но если мы примем, что рекурсивный
# вызов работает - нужно в это поверить - то мы можем убедиться в том, что
# алгоритм работает.
# Всё, что нам нужно, это простейший случай списка (базовый случай) и
# доказательство того, что, какой бы список мы ни взяли, наш алгоритм в конце
# концов приведёт нас к этому базовому случаю. Имея рекурсивное определение
# списка, приведённое выше, в качестве базового случая возьмём пустой список,
# представленный значением None.
# Предположим, что:
# 1.  list_head = list
# 2.  tail = list.next
# После выполнения первого предложения присваивания list_head и list имеют один
# и тот же тип и одно и то же значение. В таком случае, зачем мы создаем новую
# переменную?#
# Причина в том, что эти две переменные играют разные роли. Мы думаем о
# list_head как о ссылке на один узел, а о list – как о ссылке на первый узел
# списка. Эти роли не являются частью программы; они существуют в уме
# программиста.
# Модифицированная функция print_backward без переменных list_head и tail
# стала более компактной, но менее ясной.
def print_backward(ll: ListNode):  # ll - Linked List
    """Вывод на печать связанного списка в обратном порядке"""
    if ll is None:
        return
    print_backward(ll.next)
    print(ll)
# Глядя на два вызова функции, нужно помнить, что print_backward рассматривает
# свой аргумент как коллекцию, а print – как единичный объект.
# Если же взять ссылку на узел связного списка вне контекста, то ее семантика
# неоднозначна. Ссылка на узел связного списка может рассматриваться как ссылка
# на один узел или как ссылка на список.

# Обёртки и помощники
# Если нам понадобится вывести связный список в обратном порядке, заключенный
# в квадратные скобки, то, как вариант, мы можем воспользоваться функцией
# print_backward, чтобы вывести 3 2 1, и отдельно вывести открывающую и
# закрывающую скобки. Назовем новую функцию print_backward_nicely:


def print_backward_nicely(ll: ListNode):
    """
    В любом месте программы можно вызвать функцию print_backward_nicely,
    а она, в свою очередь, вызовет print_backward. Здесь print_backward_nicely
    работает как обертка, используя функцию print_backward в качестве
    помощника.

    :param ll: первый узел связанного списка
    :return:
    """
    print("[")
    print_backward(ll)
    print("]")


def remove_second(ll: ListNode) -> [ListNode, None]:
    """
    Функция удаления второго узла из связанного списка

    :param ll: связный список
    :return: ссылка на удалённый узел
    """
    if ll is None:
        return None
    first = ll
    second = ll.next
    # make the first node refer to  the third
    first.next = second.next
    # separate the second node from the rest of the list
    second.next = None
    return second


def main():
    """
    Function main

    :return:
    """
    # для тестирования создадим объект ListNode и выведем его на печать.
    node = ListNode("test")
    print(node)  # test

    # Для продолжения тестирования создадим три узла:
    node1 = ListNode(1)
    node2 = ListNode(2)
    node3 = ListNode(3)
    # Но у нас нет пока списка, так как ни один узел не связан с другим.
    # ------------------------------------------------------------------------
    # Для связи узлов нужно заставить первый узел ссылаться на второй, а второй
    # - на третий:
    node1.next = node2
    node2.next = node3
    # Ссылка в третьем узле имеет значение None, что означает конец списка.
    # Теперь знаем, как создавать узлы и связывать их в списки. Но, возможно,
    # пока не понимаем, зачем это нужно.
    # ------------------------------------------------------------------------
    # Списки полезны, поскольку дают возможность собрать многочисленные объекты
    # в единую сущность, иногда называемую коллекцией. В примере выше, первый
    # узел списка может служить ссылкой на весь список. Чтобы передать связный
    # список в качестве аргумента, достаточно передать ссылку на первый узел.
    # Например, функция print_list принимает один узел в качестве аргумента.
    print_list(node1)
    print_backward(node1)
    print_backward_nicely(node1)


if __name__ == '__main__':
    main()
